---
title: "Typesccripten: A Language Implemented in Rust"
author: "Presented by Trevor and Wolf"
---

## The Stack‚Ñ¢

- [Rust](https://rust-lang.org/): our language of choice
- [LLVM](https://llvm.org/): compiler backend
- [Nix](https://nixos.org/): build system
- [Logos](https://github.com/maciejhirsz/logos): lexer
- [Chumsky](https://github.com/zesterer/chumsky): parser generator
- [Ariadne](https://github.com/zesterer/ariadne): tasty errors

## Structure of our Project

```{mermaid}
graph TD
    A["Root Crate"]
    A --> B[parse]
    A --> C[codegen]
    A --> D[compile]
    A --> E[main.rs]
    A --> G[Tests.rs]

    %% parse
    B --> B2["parse.rs"]
    B --> B3["symbols.rs"]

    %% codegen
    C --> C2["astable.rs"]
    C --> C3["codes.rs"]
    C --> C4["expr_type.rs"]
    C --> C5["process.rs"]
    C --> C6["table.rs"]
    C --> C7["types.rs"]

    %% compile
    D --> D1["mod.rs"]
    D --> D2["generate.rs"]
    D --> D3["more to come!"]
```

We split our project up into three *crates*. 

Why? Rust macros are slow.

## The components

- Parse:
  - Lexing logic (code -> tokens)
  - Parsing logic (tokens -> AST)
  
- Codegen:
  - AST -> our IR
  
- Compile:
  - Our IR -> LLVM, binary, etc

## Lexing

::: {.columns}
::: {.column}

```rust
#[derive(Logos, Clone, Debug, PartialEq)]
pub enum Token<'a> {
    Error,

    // "Nums"
    #[regex(r"[+-]?([0-9]*)\.[0-9]+")]
    Float(&'a str),
    //...

    // Basic tokens
    #[token("int")]
    IntType,
    //...

    // üóëÔ∏è Trash
    #[regex(r"[;,.]")]
    Terminator,

    // Variables (ids)
    #[regex("[a-zA-Z_][a-zA-Z0-9_]*")]
    ID(&'a str),

    #[regex(r"[ \t\f\n]+", logos::skip)]
    Whitespace,
}
```

:::
::: {.column}

Logos is blazingly fast tokenizer that supports perl flavoured regex.

![](./images/logos-repo.png)

:::
:::

## Readme Example

::: {.columns}
::: {.column}

```rust
use logos::Logos;

#[derive(Logos, Debug, PartialEq)]
#[logos(skip r"[ \t\n\f]+")] // Ignore this regex pattern between tokens
enum Token {
    // Tokens can be literal strings, of any length.
    #[token("fast")]
    Fast,

    #[token(".")]
    Period,

    // Or regular expressions.
    #[regex("[a-zA-Z]+")]
    Text,
}



```

:::
::: {.column}

```rust
fn main() {
    let mut lex = Token::lexer("Create 
           ridiculously fast Lexers.");

    assert_eq!(lex.next(), Some(Ok(Token::Text)));
    assert_eq!(lex.span(), 0..6);
    assert_eq!(lex.slice(), "Create");

    assert_eq!(lex.next(), Some(Ok(Token::Text)));
    assert_eq!(lex.span(), 7..19);
    assert_eq!(lex.slice(), "ridiculously");

    assert_eq!(lex.next(), Some(Ok(Token::Fast)));
    assert_eq!(lex.span(), 20..24);
    assert_eq!(lex.slice(), "fast");

    assert_eq!(lex.next(), Some(Ok(Token::Text)));
    assert_eq!(lex.slice(), "Lexers");
    assert_eq!(lex.span(), 25..31);

    assert_eq!(lex.next(), Some(Ok(Token::Period)));
    assert_eq!(lex.span(), 31..32);
    assert_eq!(lex.slice(), ".");

    assert_eq!(lex.next(), None);
}
```

:::
:::

## Parsing

We used *chumksy* for our parser:

```rust
let array_dimensions = select! {
    // For every int token from Logos, parse it (as a string) into a number
    Token::Int(n) => n.parse::<usize>().unwrap()
}
.or_not() // for dynamic arrays, like int[][4]
// and all that stuff, with [] around it
.delimited_by(just(Token::LBracket), just(Token::RBracket))
.repeated() // and many times! int[][5][2][]
.collect::<Vec<_>>(); // And get all that
```

The beauty of chunksy is that it's expressive -- you just describe the shape of what you want to parse.

## Chumsky is Top Down ‚¨áÔ∏è

```rust
let expr = recursive(|expr| {
    let parenthesized = expr
        .clone()
        .delimited_by(just(Token::LParen), just(Token::RParen))
        .map(|s| Expr::Group(Box::new(s)));
```

It's recursive and gives you your parser generator in a callback!

## Array dimensions (continued!)

::: {.r-stack}

```rust
let declaration = select! {
    // Token is logos-land thing, and Type is our own enum (just for types!)
    Token::IntType => Type::Int,
    Token::FloatType => Type::Float,
    Token::BooleanType => Type::Boolean,
} // a type, followed by MAYBE array indexes
.then(array_dimensions.or_not())
.then(select! { Token::ID(s) => s.to_string() }) // int[][2] foobar
.map(|((type_, quantities), name)| match quantities {
    // type_: a Type
    // quantities: Option<Vec<Option<usize>>>
    //             maybe we have array dimensions, which maybe have actual numbers in them
    Some(quantities) => {
        Expr::Declare(
            // (Int, Some([Some(12), Some(4), None, Some(2)]))
            //
            // We begin where type is just Int
            //
            // 1) Then we're hit with previous acc, which is initially Int, and the size of that dim, Some(12)
            // 2) We match { Some(12) => Type::Array(Int, 12)}
            // 3) Then we return that type, Type::Array(Int, 12)}
            // 4) Now we're hit with the previous acc: Type::Array(Int, 12)} and the next size, Some(4)
            // 5) We mush it all together into:
            // 6) Type::Array(
            //      Type::Array(
            //        Type::Array(
            //          Type::Array(
            //            Type::Int, 
            //            Some(12)
            //          ), 
            //          Some(4)
            //        ), 
            //        None
            //      ), 
            //      Some(2)
            //    )
            quantities.iter().fold(type_, |acc, size| match size {
                Some(size) => Type::Array(acc.into(), Some(*size)),
                _ => Type::Array(acc.into(), None),
            }),
            name,
        )
    }
    None => Expr::Declare(type_, name)
});
```

![](images/russian-doll.jpg){.fragment}

:::

## Chumsky has good type inference

![](./images/big-type.gif)

## Precedence is "easy"

```rust
let multiplication = indexed.clone().foldl(
    just(Token::Mul)
        .or(just(Token::Div))
        .then(indexed.clone())
        .repeated()
        .at_least(1),
    |lhs, (op, rhs)| match op {
        Token::Mul => Expr::Mul(lhs.into(), rhs.into()),
        Token::Div => Expr::Div(lhs.into(), rhs.into()),
        _ => unreachable!("unexpected operator"),
    },
);

// Collapse all sequences of multiplication/division, so it takes higher
// precedence
// 
// foldl(12 / 4 * 2)
// 12 is consumed, we now have Expr<Int<12>>
// then we consume 4, we now have Div<Expr<Int<12>>, Expr<Int<4>>>
// then we consume 2, we now have Mul<Div<Expr<Int<12>>, Expr<Int<4>>>, Expr<Int<2>>>
//
// And precedence is preserved ü™Ñ

let mterm = multiplication.clone().or(indexed.clone());

let addition = mterm.clone().foldl(
    just(Token::Add)
        .or(just(Token::Sub))
        .then(mterm.clone())
        .repeated()
        .at_least(1),
    |lhs, (op, rhs)| match op {
        Token::Add => Expr::Add(lhs.into(), rhs.into()),
        Token::Sub => Expr::Sub(lhs.into(), rhs.into()),
        _ => unreachable!("unexpected operator"),
    },
);

// Similar idea, now multiplication and division are single blocks so we can
// just treat them as single elements
```

## Theory!

![](./images/thinking.jpg)

```ts
bar[1 + 12] // obviously works
bar[get_the_weather_next_week()] // impure!
bar[floor(pi(24) + 12/2) as uint] // pure, this could be made to work!
```

## The meaning of Purity üíß

::: {.columns}

::: {.column}

::: {.r-stack}

```java
// This is NOT pure
import java.net.http.*;
import java.net.URI;

public class NetworkExample {
    public static void main(String[] args) throws Exception {
        HttpClient client = HttpClient.newHttpClient();
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create("https://api.example.com/data"))
            .build();

        HttpResponse<String> response = client.send(request, 
            HttpResponse.BodyHandlers.ofString());

        System.out.println(response.body());
    }
}
```

![](./images/i-love-trash.png){.fragment}

:::

:::
::: {.column}

```nix
# This is pure
builtins.fetchurl {
  url = "https://api.example.com/data";
  sha256 = "sha256-ITeH8GBpQTw9457ICZBddQEBjlXMmilML067q0e6vqY=";
}
```

If it's "pure" and we know the inputs, then we are *definitely* able to figure out the outputs with no further information.

:::
:::

## Purify - Pure by Default

::: {.columns}

::: {.column}

```{.ts filename="pure_example.tsn"}
// PURE (by default!!)

function is_sunny() {
  true
}
```

:::
::: {.column}

Our language is **pure by default** - functions cannot perform side effects unless explicitly marked otherwise.

This ensures predictable behavior and enables powerful optimizations.

:::
:::

## Purify - Impure Operations

::: {.columns}

::: {.column}

:::{.r-stack}

```{.ts filename="trash_example.tsn"}
IMPURE {
  function is_sunny() {;
    return get
      ("https://api.example.com/weather")
      .as_json()["is_sunny"];
  };
}
```

![](./images/i-love-trash.png){.fragment}

:::

:::
::: {.column}

```ansi
$ tsn purify .

‚ö†Ô∏è  WARNING: IMPURE OPERATIONS DETECTED ‚ö†Ô∏è
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                           ‚ïë
‚ïë  üö® YOU ARE ABOUT TO PERFORM IMPURE OPERATIONS! üö®        ‚ïë
‚ïë                                                           ‚ïë
‚ïë  This will make network calls and other side effects that ‚ïë
‚ïë  cannot be guaranteed to produce consistent results.      ‚ïë
‚ïë                                                           ‚ïë
‚ïë  Are you ABSOLUTELY SURE you want to proceed?             ‚ïë
‚ïë                                                           ‚ïë
‚ïë  Type 'YES I UNDERSTAND THE RISKS' to continue:           ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

$ YES I UNDERSTAND THE RISKS
```

:::
:::

## Purify - Hash-Based Purity

::: {.columns}

::: {.column}

```{.ts filename="purify_example.tsn"}
Purify {
  function getTheWeather() {
    get("https://api.example.com/weather").as_json()["is_sunny"]
  }
}
```

```{.nix filename="Hashfile"}
{
  "sha256-qOfWjQ2JQSQL15KLh6D7xQhx0qgZlYZTYlcEiRuAMMw=" = # input hash
  "sha256-ITeH8GBpQTw9457ICZBddQEBjlXMmilML067q0e6vqY="; # hash at lock time
}
```

:::
::: {.column}

```ansi
$ tsn purify .

‚ú® Successfully purified function:
‚îå‚îÄ getTheWeather()
‚îÇ  get("https://api.example.com/weather").as_json()["is_sunny"]
‚îî‚îÄ üîí sha256-qOfWjQ2JQSQL15KLh6D7xQhx0qgZlYZTYlcEiRuAMMw=

üìù Updated Hashfile with new lock
```

The `Purify` block allows us to turn impure operations into pure ones by locking their results with content hashes.

:::
:::

## Statements are Bad

We regret having to add statements to our language

They will be removed in version 2.0

::: {.columns}

::: {.column}

```rust
// In our language, everything is an expression
let foo = {
    if weather_is_sunny() {
        "Go outside!"
    } else {
        "Stay inside"
    }
};
// "Go outside!"
```

:::
::: {.column}

```java
// Traditional statements in Java
String foo;
if (weatherIsSunny()) {
    foo = "Go outside!";
} else {
    foo = "Stay inside";
}
```

<<<EOT (end of theory)

:::
:::

## Pause -- what is a struct?

A struct is just a way to group related data together. Here's a super simple example:

::: {.columns}
::: {.column}

```c
struct Point {
    int x;    // 4 bytes
    int y;    // 4 bytes
};
```

:::
::: {.column}

**Memory Layout (ABI):**
```
Offset | Size | Field
-------|------|------
0      | 4    | x
4      | 4    | y
-------|------|------
Total: 8 bytes
```

:::
:::

That's it! The compiler lays out the fields in memory one after another.

## What is a trait? {.scrollable}

```rust
/// Trait for types that can provide their size in bytes.
pub trait SizeOf {
    /// Get the size of the Type in bytes.
    fn size_of(&self) -> usize;
}

impl SizeOf for Type {
    fn size_of(&self) -> usize {
        match self {
            Type::Int => std::mem::size_of::<i32>(),
            Type::Float => std::mem::size_of::<f64>(),
            Type::Boolean => std::mem::size_of::<bool>(),
            Type::Array(inner, size) => {
                match size {
                    Some(s) => inner.size_of() * (*s as usize), // actual size * recursive inner size
                    None => std::mem::size_of::<usize>(),       // Size unknown for dynamic arrays
                }
            }
        }
    }
}
```

And things do not impl traits, you just impl them onto things and those things happen to get it

## Our structure {.scrollable}

```{mermaid}
erDiagram
    AssignmentCST {
        int tmp_name_counter
    }

    ScopeNode {
        HashMap scope_map
    }

    AssignmentIdentifier {
        string name
        bool is_temp
    }

    AssignmentValue {
        Option_Expr value
    }

    AssignmentMeta {
        Type type_
        int address
    }

    AssignmentLayerMeta {
        Option_usize entry_offset
        int latest_memory_offset
    }

    Expr {
        string variant "Add|Sub|Mul|Div|ID|Const|Assign|Index..."
    }

    Type {
        string kind "Int|Float|Boolean|Array"
        Type inner_type
        int size_opt
    }

    AssignmentCST ||--o{ ScopeNode : contains
    ScopeNode ||--o{ AssignmentIdentifier : has
    ScopeNode ||--o{ AssignmentValue : maps_to
    ScopeNode ||--|| AssignmentLayerMeta : has_meta
    AssignmentValue ||--|| AssignmentMeta : has_meta
    AssignmentValue ||--o| Expr : contains
    AssignmentMeta ||--|| Type : has_type
    Type ||--o| Type : inner_type
```

## Chained Symbol Table (but super super super super generic) {.scrollable}

- We have an array of layers
- Each layer has a map of assignments

In rust, we can't have every node have a parent pointer and child pointer, because Rust's ownership model prevents circular references.

If node A has a pointer to child B, and child B has a pointer back to parent A, we'd have a cycle that Rust's borrow checker cannot safely manage.

## Example of the idea

```ansi
ChainedSymbolTable {
  parents: Vec<HashMap'layer1; HashMap'layer2;>,
}

Which, for something like:

{ // layer 1
  int foo;
  int bar;
  foo = 15;
  bar = 12

  {
    // layer 2
    int foo;
    foo = 16;
  }
}

Disclaimer: comments not supported in Trevorscripten
```

```ansi
And HashMap'layer1 looks like:
foo -> AssignmentValue { value: Some(15), meta: { type: Int, address: 0 } }
bar -> AssignmentValue { value: Some(12), meta: { type: Int, address: 4 } }

And HashMap'layer2 looks like:
foo -> AssignmentValue { value: Some(16), meta: { type: Int, address: 8 } }

When we lookup "foo", we search from the innermost scope (layer2) first,
so we get the value 16. When we lookup "bar", it's not in layer2, so we
search up to layer1 and find the value 12.

When we exit the inner scope, we pop layer2 off the stack, and "foo" 
resolves back to its outer scope value of 15.

It's a stack of hash maps (each layer).
```

## What it looks like

- Identifiers are keys in layers
- Nodes are the actual layers
- Symbols are values in layers

## Code!

```rust
#[derive(Debug, Clone)]
pub struct ChainedSymbolTable<I: Identifier, A: Symbol, K: NodeMetadataType> {
    parents: Vec<ScopeNode<I, A, K>>,
}

impl<I: Identifier, A: Symbol, K: NodeMetadataType> Default for ChainedSymbolTable<I, A, K> {
    fn default() -> Self {
        ChainedSymbolTable {
            parents: vec![ScopeNode::new(HashMap::new(), K::default())],
        }
    }
}

impl<I: Identifier, A: Symbol, K: NodeMetadataType> ChainedSymbolTable<I, A, K> {
    pub fn push_scope(&mut self, meta: Option<K>) {
        self.parents
            .push(ScopeNode::new(HashMap::new(), meta.unwrap_or_default()));
    }

    pub fn pop_scope(&mut self) -> Option<ScopeNode<I, A, K>> {
        self.parents.pop()
    }

    /// Get the current scope, or search through parent scopes if not found
    pub fn get(&self, key: &I) -> Option<A> {
        if self.get_current_scope().is_none() {
            return None;
        }

        for scope in self.parents.iter().rev() {
            if let Some(value) = scope.scope_node.get(key) { // recurse here
                return Some(value.clone());
            }
        }

        None
    }

    /// Remove a variable from the current scope
    pub fn remove(&mut self, key: &I) -> Option<A> {
        if let Some(current_scope) = self.parents.last_mut() {
            current_scope.scope_node.remove(key)
        } else {
            None
        }
    }

    /// Search upwards and update the value of the first matching key found
    pub fn update(&mut self, key: &I, value: A) -> Result<(), ()> {
        for scope in self.parents.iter_mut().rev() {
            if scope.scope_node.contains_key(key) {
                scope.scope_node.insert(key.clone(), value);
                return Ok(());
            }
        }
        Err(())
    }

    /// Add an item to the current scope only. Adds a top level scope if you have popped off all scopes.
    pub fn insert(&mut self, key: I, value: A) -> bool {
        if self.get_current_scope().is_none() {
            self.push_scope(None); // if there were no scopes we can safely init the initial offset to 0 via defaulting
        }

        if let Some(current_scope) = self.parents.last_mut() {
            current_scope.scope_node.insert(key, value);
            return true;
        }

        false
    }

    pub fn get_current_scope(&self) -> Option<&ScopeNode<I, A, K>> {
        self.parents.last()
    }

    pub fn get_current_meta(&self) -> Option<&K> {
        self.get_current_scope().map(|scope| &scope.meta)
    }
}
```

## Example Usage

```rust
// Note: no metadata

#[test]
fn test_symbol_table_chaining() {
    let mut table = ChainedSymbolTable::<String, i32, ()>::default();
    table.insert("x".to_string(), 100);

    // Push a new scope (like entering a new block)
    table.push_scope(None);
    // Insert into new scope
    table.insert("y".to_string(), 200);

    assert_eq!(table.get(&"y".to_string()), Some(200));
    assert_eq!(table.get(&"x".to_string()), Some(100)); // from parent scope
    assert_eq!(table.get(&"z".to_string()), None);
}
```

## But how do we do Temp Vars?

Well, we just have a key that specifies whether it's temporary

```rust
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct AssignmentIdentifier {
    pub name: String,
    pub is_temp: bool,
}
```

And we just #[derive(Hash)] :)

```rust
#[derive(Clone, Debug)]
pub struct AssignmentValue {
    pub value: Option<AssignmentContents>,
    pub meta: AssignmentMeta,
}
```

And now we have magical two different types of keys, those that are temp and those that are not.

## Temp vars in action

::: {.columns}
::: {.column}

```rust
pub fn get(&self, key: &str) -> Option<(AssignmentValue, usize)> {
    self.table
        .get(&AssignmentIdentifier::new(key.to_string(), false))
        .and_then(|val| {
            self.table.get_current_meta().map(|meta| {
                (
                    val.clone(),
                    meta.entry_offset.unwrap_or(0) + val.meta.address,
                )
            })
        })
}
```

:::
::: {.column}

```rust
pub fn get_tmp(&self, key: &str) -> Option<(AssignmentValue, usize)> {
    self.table
        .get(&AssignmentIdentifier::new(key.to_string(), true))
        .and_then(|val| {
            self.table.get_current_meta().map(|meta| {
                (
                    val.clone(),
                    meta.entry_offset.unwrap_or(0) + val.meta.address,
                )
            })
        })
}
```

:::
:::

## Keeping an eye on the temps {.scrollable}

We'd lose them if we didn't keep a counter!

```rust
pub fn clear_temps(&mut self) -> Result<(), ProcessingError> {
    let mut offset_to_remove = 0;

    for i in 0..self.tmp_name_counter.clone() {
        let table = self.get_table_mut();
        let thing_to_remove = &AssignmentIdentifier::new(i.to_string(), true);
        match table.remove(thing_to_remove) {
            Some(value) => {
                offset_to_remove += value.meta.type_.size_of();
                self.tmp_name_counter -= 1;
            }
            None => return Err(ProcessingError::WasNotThere),
        }
    }

    self.tmp_name_counter = 0;
    self.get_current_meta_mut()
        .ok_or(ProcessingError::NoExistingScope)?
        .latest_memory_offset -= offset_to_remove;

    Ok(())
}
```

## Generating IR {.scrollable}

We have addresses!

```rust
#[derive(Clone, Debug)]
pub enum AddrType {
    Const(Consts),
    Var {
        id: AssignmentIdentifier,
        address: usize,
        type_: Type,
    },
}

impl AddrType {
    /// Extract the address of the variable if it has one
    pub fn address(&self) -> Option<usize> {
        match self {
            AddrType::Const(_) => None,
            AddrType::Var { address, .. } => Some(*address),
        }
    }
}
```

```rust
pub mod opt_codes {
    use parse::symbols::Expr;

    use crate::codes::AddrType;

    #[derive(Clone, Debug)]
    pub enum BiOpCode {
        Add,
        Subtract,
        Divide,
        Multiply,
    }

    /// To turn an expression into a biopcode
    impl TryFrom<Expr> for BiOpCode {
        type Error = Error;

        fn try_from(value: Expr) -> Result<Self, Self::Error> {
            match value {
                Expr::Add(_, _) => Ok(BiOpCode::Add),
                Expr::Sub(_, _) => Ok(BiOpCode::Subtract),
                Expr::Mul(_, _) => Ok(BiOpCode::Multiply),
                Expr::Div(_, _) => Ok(BiOpCode::Divide),
                _ => Err(Error::NotBiOp),
            }
        }
    }
    
    // Into is basically defined to be:
    trait Into<T> {
        fn into(self) -> T;
    }
    
    impl<T, U> Into<U> for T
    where
        U: From<T>, // U satifies this, AKA you can do for any From<T> to get to
                    // U, thus you can do for any Into<U> to get to T
    {
        fn into(self) -> U {
            U::from(self)
        }
    }
    
    // So we could turn an arbitrary expression into a biopcode
    // doing something like:
    //
    // let BiOpCode = myExpr.into()
```

## And the rest

```rust
    pub enum UniOpCode {
        Negation,
        Assign,
        /// Dereferences an address and copies the value to that address.
        ///
        /// Takes an address and copies the value that lives at that address and stores it in dest.
        CopyFrom,
        /// Copies the input value to the address stored at the address of the destination.
        CopyTo,
    }

    /// A regular op code that takes zero operands
    pub enum ZOpCode {
        NoOp,
        Declare,
    }

    pub enum OpCode {
        BiOp(BiOpCode, [AddrType; 2]),
        UniOp(UniOpCode, [AddrType; 1]),
        ZOp(ZOpCode),
    }
}
```

## Create an `IntermediateCode` from a `StmtList`

```rust
let stmt_list = StmtList::Stmt(vec![
    Stmt::Expr(Box::new(Expr::Declare(Type::Int, "x".to_string()))),
    Stmt::Expr(Box::new(Expr::Assign("x".to_string(), Box::new(Expr::Const(Consts::Int(2.0))), None))),
]);

let intermediate_code: IntermediateCode = stmt_list.try_into().unwrap();

// If we have:

impl TryFrom<StmtList> for IntermediateCode {
    type Error = ProcessError;

    fn try_from(value: StmtList) -> Result<Self, ProcessError> {
        let (_chained_symbol_table, intermediate_code) =
            get_chained_symbol_table_and_intermediate(&value)?;
        Ok(intermediate_code)
    }
}
```

## What it actually looks like:

```rust
pub fn get_chained_symbol_table_and_intermediate(
    stmt_list: &StmtList,
) -> Result<(AssignmentCST, IntermediateCode), ProcessError> {
    let mut chained_symbol_table = AssignmentCST::default();
    let mut intermediate_code = IntermediateCode::default();

    let mut tmp_counter = 0;

    fn process_stmt(
        stmt: &Stmt,
        chained_symbol_table: &mut AssignmentCST,
        intermediate_code: &mut IntermediateCode,
    ) -> Result<(), ProcessError> {
        match stmt {
            Stmt::Expr(expr) => {
                process_expr(expr.as_ref(), chained_symbol_table, intermediate_code).unwrap();
                Ok(())
            }
            Stmt::Block(block_stmts) => {
                // Push a new scope for the block
                chained_symbol_table.push_scope();

                // Process all statements in the block
                block_stmts.iter().try_for_each(|stmt| {
                    process_stmt(stmt, chained_symbol_table, intermediate_code)
                })?;

                // No instructions since they don't return anything!

                // Pop the scope when exiting the block
                chained_symbol_table.pop_scope();

                Ok(())
            }
            // TODO! not parsing else statements
            Stmt::If(_, stmt, _el) => process_stmt(stmt.as_ref(), chained_symbol_table, intermediate_code),
            Stmt::While(_, stmt, _el) => process_stmt(stmt.as_ref(), chained_symbol_table, intermediate_code),
            Stmt::DoWhile(_, stmt) => process_stmt(stmt.as_ref(), chained_symbol_table, intermediate_code),
        }
    }

    fn process_expr(
        expr: &Expr,
        chained_symbol_table: &mut AssignmentCST,
        intermediate_code: &mut IntermediateCode,
    ) -> Result<AddrType, ProcessError> {
        match expr {
            Expr::Declare(types, id) => {
                let addr = chained_symbol_table
                    .set(id, types.clone(), None)
                    .or_else(|err| Err(ProcessError::CSTError(CSTError::CSTError(err))))?;

                let dest_var = AddrType::Var {
                    id: AssignmentIdentifier::new(id.clone(), false),
                    address: addr,
                    type_: types.clone(),
                };

                let instruction = Instruction {
                    opt_code: opt_codes::OpCode::ZOp(opt_codes::ZOpCode::Declare),
                    dest_var: dest_var.clone(),
                };
                intermediate_code.add_instruction(instruction);

                Ok(dest_var)
            }
            Expr::Assign(id, value, indexes) => {
                // assigning value into id `id[...indexes] = <value>`
                let rhs_wider =
                    value
                        .as_ref()
                        .get_type(chained_symbol_table)
                        .ok_or(ProcessError::CSTError(CSTError::TypeError(
                            // TODO: more specific error (make get_type not return Option)
                            TypeError::FailToWidenOrReferenceError,
                        )))?;

                // Table is the active scope
                let (lhs_narrower, lhs_narrower_addr) =
                    chained_symbol_table.get(id).ok_or(ProcessError::CSTError(
                        CSTError::ReferenceError(ReferenceError::VariableDoesntExist),
                    ))?;

                // Get the value of id at the current scope
                let lhs_type = &lhs_narrower
                    .get_type_at_indexes(match indexes {
                        Some(idx) => idx.len(),
                        _ => 0,
                    })
                    .ok_or(ProcessError::CSTError(CSTError::TypeError(
                        TypeError::AssignmentTypeMismatch,
                    )))?;

                // Auto widen the type of the key-val
                // relation to be the widest of
                // expression
                let widened_type = rhs_wider.widen(lhs_type).ok_or(ProcessError::CSTError(
                    CSTError::TypeError(TypeError::AssignmentTypeMismatch),
                ))?;

                // Make sure that widened_type is the
                // same as the assignment type (you
                // can't assign to something that is
                // smaller)
                if *lhs_type != widened_type {
                    return Err(ProcessError::CSTError(CSTError::TypeError(
                        TypeError::AssignmentTypeMismatch,
                    )));
                }

                // Recursively eval the right hand side so we can find the address containing
                // the resolved value or where it will eventually be
                let eval_rhs =
                    process_expr(value.as_ref(), chained_symbol_table, intermediate_code)?;

                match indexes {
                    Some(ptr_offset) => {
                        // It is an array
                        let dest_addr_ptr = Type::get_ptr_to_expr(lhs_type, ptr_offset.as_slice())
                            .map(|offset_expr| {
                                // address to where the number that we need to assign to is located, must be dereferenced
                                process_expr(
                                    &Expr::Add(
                                        Box::new(offset_expr),
                                        Box::new(Expr::Const(Consts::Int(
                                            lhs_narrower_addr as f32,
                                        ))),
                                    ),
                                    chained_symbol_table,
                                    intermediate_code,
                                )
                            })
                            .transpose()?
                            .unwrap_or(AddrType::Const(Consts::Int(0.0)));

                        let type_at_index_pos = lhs_narrower
                            .get_type_at_indexes(ptr_offset.len())
                            .ok_or(ProcessError::CSTError(CSTError::TypeError(
                                TypeError::AssignmentTypeMismatch,
                            )))?;

                        let dest_addr_ptr_addr = match dest_addr_ptr.address() {
                            Some(addr) => addr,
                            None => {
                                // Make a temp var if it was a const
                                let (_tmp_var_name, tmp_var_addr) =
                                    chained_symbol_table.add_tmp(Type::Int, None).map_err(
                                        |err| ProcessError::CSTError(CSTError::CSTError(err)),
                                    )?;
                                tmp_var_addr
                            }
                        };

                        let dest_addr_ptr = AddrType::Var {
                            id: AssignmentIdentifier::new(id.clone(), true),
                            address: dest_addr_ptr_addr,
                            type_: type_at_index_pos,
                        };

                        intermediate_code.add_instruction(Instruction {
                            opt_code: opt_codes::OpCode::UniOp(
                                opt_codes::UniOpCode::CopyTo,
                                [eval_rhs],
                            ),
                            dest_var: dest_addr_ptr.clone(),
                        });

                        Ok(dest_addr_ptr)
                    }
                    None => {
                        let dest_var = AddrType::Var {
                            id: AssignmentIdentifier::new(id.clone(), false),
                            address: lhs_narrower_addr,
                            type_: widened_type,
                        };

                        intermediate_code.add_instruction(Instruction {
                            opt_code: opt_codes::OpCode::UniOp(
                                opt_codes::UniOpCode::Assign,
                                [eval_rhs],
                            ),
                            dest_var: dest_var.clone(), // No array indexing
                        });

                        Ok(dest_var)
                    }
                }
            }
            Expr::ID(id) => {
                let (var, var_addr) =
                    chained_symbol_table.get(id).ok_or(ProcessError::CSTError(
                        CSTError::ReferenceError(ReferenceError::VariableDoesntExist),
                    ))?;

                Ok(AddrType::Var {
                    id: AssignmentIdentifier::new(id.clone(), false),
                    address: var_addr,
                    type_: var.meta.type_.clone(),
                })
            }
            Expr::Const(c) => Ok(AddrType::Const(c.clone())),
            Expr::Add(a, b)
            | Expr::Sub(a, b)
            | Expr::Div(a, b)
            | Expr::Mul(a, b)
            | Expr::GT(a, b)
            | Expr::LEq(a, b)
            | Expr::LT(a, b)
            | Expr::GEq(a, b)
            | Expr::Eql(a, b)
            | Expr::NEq(a, b) => {
                let a = a.as_ref();
                let b = b.as_ref();

                let widened_type = a
                    .get_type(chained_symbol_table)
                    .unwrap()
                    .widen(&b.get_type(chained_symbol_table).unwrap())
                    .unwrap();

                // Push scope and then pop it later to automatically clean up the temp var we create
                chained_symbol_table.push_scope();

                let (tmp_var_name, tmp_var_addr) = chained_symbol_table
                    .add_tmp(widened_type.clone(), None)
                    .map_err(|err| ProcessError::CSTError(CSTError::CSTError(err)))?;

                let a_addr = process_expr(a, chained_symbol_table, intermediate_code)?;
                let b_addr = process_expr(b, chained_symbol_table, intermediate_code)?;

                let dest_var = AddrType::Var {
                    id: AssignmentIdentifier::new(tmp_var_name.clone(), false),
                    address: tmp_var_addr,
                    type_: widened_type,
                };

                let new_instruction = Instruction {
                    opt_code: opt_codes::OpCode::BiOp(
                        expr.try_into().map_err(|_| {
                            ProcessError::CSTError(CSTError::TypeError(
                                TypeError::FailToWidenOrReferenceError,
                            ))
                        })?,
                        [a_addr, b_addr],
                    ),
                    dest_var: dest_var.clone(),
                };

                intermediate_code.add_instruction(new_instruction);

                chained_symbol_table.pop_scope();

                Ok(dest_var)
            }
            k => {
                todo!("Expression processing not implemented for {:?}", k)
            }
        }
    }

    match stmt_list {
        StmtList::Stmt(stmts) => {
            for stmt in stmts {
                process_stmt(stmt, &mut chained_symbol_table, &mut intermediate_code)?;
            }
        }
    }

    chained_symbol_table.pop_scope();
    Ok((chained_symbol_table, intermediate_code))
}
```

## Maybe Index???

```rust
pub trait MaybeIndex {
    fn get_ptr_to_idx_type(array_type: &Type, index: &[usize]) -> Option<usize>;
    fn get_ptr_to_expr(array_type: &Type, index_list: &[Expr]) -> Option<Expr>;
    fn get_arr_dim_list(array_type: &Type) -> (Option<Vec<usize>>, Type);
}

/// Get the pointer to the index type of an array type.
///
/// Returns None if the provided type is not an array.
impl MaybeIndex for Type {
    fn get_ptr_to_idx_type(array_type: &Type, index: &[usize]) -> Option<usize> {
        // int[5][5] a; -> [X_0 ... X_24 X_25]
        // a[1][3] -> 5 * 1 + 3 = 8
        match Type::get_arr_dim_list(array_type) {
            (Some(dim_list), inner_type) => Some(
                dim_list.iter().enumerate().fold(0, |acc, (i, dim_size)| {
                    (acc * dim_size) + index.get(i).unwrap_or(&0)
                }) * inner_type.size_of(),
            ),
            _ => None,
        }
    }

    fn get_arr_dim_list(array_type: &Type) -> (Option<Vec<usize>>, Type) {
        if let Type::Array(_, _) = array_type {
            let mut dims = Vec::new();
            let mut current_type = array_type;
            let mut encountered_dynamic = false;

            while let Type::Array(inner_type, size_opt) = current_type {
                if let Some(size) = size_opt {
                    dims.push(*size);
                } else {
                    // Dynamic array, cannot determine all dimensions
                    encountered_dynamic = true;
                }

                current_type = inner_type;
            }

            if encountered_dynamic {
                return (None, current_type.clone());
            }

            (Some(dims), current_type.clone())
        } else {
            (None, array_type.clone())
        }
    }

    fn get_ptr_to_expr(array_type: &Type, index_list: &[Expr]) -> Option<Expr> {
        // int[5][5] a; -> [X_0 ... X_24 X_25]
        // a[1][3] -> 5 * 1 + 3 = 8
        match Type::get_arr_dim_list(array_type) {
            (Some(dim_list), inner_type) => {
                Some(Expr::Mul(
                    Box::new(dim_list.iter().enumerate().fold(
                        Expr::Const(Consts::default()),
                        |acc, (i, _dim_size)| {
                            Expr::Add(
                                Box::new(Expr::Mul(
                                    Box::new(acc),
                                    Box::new(Expr::Const(Consts::default())), // Should be dim_size as Expr
                                )),
                                Box::new(
                                    index_list
                                        .get(i)
                                        .unwrap_or(&Expr::Const(Consts::default()))
                                        .clone(),
                                ),
                            )
                        },
                    )),
                    Box::new(Expr::Const(Consts::Int(inner_type.size_of() as f32))),
                ))
            }
            _ => None,
        }
    }
}

/// Trait for types that can provide their size in bytes.
pub trait SizeOf {
    /// Get the size of the Type in bytes.
    fn size_of(&self) -> usize;
}

impl SizeOf for Type {
    fn size_of(&self) -> usize {
        match self {
            Type::Int => std::mem::size_of::<i32>(),
            Type::Float => std::mem::size_of::<f64>(),
            Type::Boolean => std::mem::size_of::<bool>(),
            Type::Array(inner, size) => {
                match size {
                    Some(s) => inner.size_of() * (*s as usize), // actual size * recursive inner size
                    None => std::mem::size_of::<usize>(),       // Size unknown for dynamic arrays
                }
            }
        }
    }
}
```

## Example!

```rust
#[test]
fn test_get_arr_idx_for_expr() {
    let array_type = Type::Array(Box::new(Type::Int), Some(10));
    let index_list = vec![Expr::ID("y".into())];
    let ptr_expr = Type::get_ptr_to_expr(&array_type, &index_list).unwrap();
    assert_eq!(
        ptr_expr,
        Expr::Mul(
            Box::new(Expr::Add(
                Box::new(Expr::Mul(
                    Box::new(Expr::Const(Consts::Int(0.0))),
                    Box::new(Expr::Const(Consts::Int(0.0)))
                )),
                Box::new(Expr::ID("y".into()))
            )),
            Box::new(Expr::Const(Consts::Int(4.0)))
        )
    );
}
```

# LLVM Land

![](./images/llvm.png)

```rust
use inkwell::AddressSpace;
use inkwell::context::Context;
use inkwell::module::Module;

fn generate_program(context: &Context) -> Module {
    let module = context.create_module("stdin_adder");
    let builder = context.create_builder();

    // Types
    let i32_type = context.i32_type();
    let i8_type = context.i8_type();
    let i8_ptr_type = i8_type.ptr_type(AddressSpace::default());

    // External function declarations
    let scanf_type = i32_type.fn_type(&[i8_ptr_type.into()], true);
    let scanf_fn = module.add_function("scanf", scanf_type, None);

    let printf_type = i32_type.fn_type(&[i8_ptr_type.into()], true);
    let printf_fn = module.add_function("printf", printf_type, None);

    // String constants
    let input_format = "%d %d\0";
    let output_format = "%d\n\0";
    // Main function
    let main_type = i32_type.fn_type(&[], false);
    let main_fn = module.add_function("main", main_type, None);
    let entry_block = context.append_basic_block(main_fn, "entry");

    builder.position_at_end(entry_block);

    let input_format_global = builder
        .build_global_string_ptr(input_format, ".input_fmt")
        .unwrap();
    let output_format_global = builder
        .build_global_string_ptr(output_format, ".output_fmt")
        .unwrap();

    // Allocate space for two integers
    let a_alloca = builder.build_alloca(i32_type, "a").unwrap();
    let b_alloca = builder.build_alloca(i32_type, "b").unwrap();

    // Call scanf to read two integers
    builder
        .build_call(
            scanf_fn,
            &[
                input_format_global.as_pointer_value().into(),
                a_alloca.into(),
                b_alloca.into(),
            ],
            "scanf_call",
        )
        .unwrap();

    // Load the values
    let a_val = builder
        .build_load(i32_type, a_alloca, "a_val")
        .unwrap()
        .into_int_value();
    let b_val = builder
        .build_load(i32_type, b_alloca, "b_val")
        .unwrap()
        .into_int_value();

    // Add the values
    let sum = builder.build_int_add(a_val, b_val, "sum").unwrap();

    // Call printf to output the result
    builder
        .build_call(
            printf_fn,
            &[output_format_global.as_pointer_value().into(), sum.into()],
            "printf_call",
        )
        .unwrap();

    // Return 0
    let zero = i32_type.const_int(0, false);
    builder.build_return(Some(&zero)).unwrap();

    module
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let context = Context::create();
    let module = generate_program(&context);

    // Print the LLVM IR
    println!("{}", module.to_string());

    Ok(())
}
```

## The actual IR

```llvm
; ModuleID = 'stdin_adder'
source_filename = "stdin_adder"

; Global string constants for scanf and printf format strings
; "%d %d\0" - format string for reading two integers from stdin
@.input_fmt = private unnamed_addr constant [6 x i8] c"%d %d\00", align 1
; "%d\n\0" - format string for printing an integer followed by newline
@.output_fmt = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1

; External function declaration for scanf - reads formatted input from stdin
; Returns number of items successfully read
declare i32 @scanf(ptr, ...)

; External function declaration for printf - writes formatted output to stdout
; Returns number of characters written
declare i32 @printf(ptr, ...)

; Main function definition - entry point of the program
define i32 @main() {
entry:
  ; Allocate stack space for two 32-bit integers
  ; %a will hold the first input number
  %a = alloca i32, align 4
  ; %b will hold the second input number
  %b = alloca i32, align 4

  ; Call scanf to read two integers from stdin
  ; Pass format string and pointers to our allocated variables
  %scanf_call = call i32 (ptr, ...) @scanf(ptr @.input_fmt, ptr %a, ptr %b)

  ; Load the actual values from memory into registers
  ; Load first integer from address %a into %a_val
  %a_val = load i32, ptr %a, align 4
  ; Load second integer from address %b into %b_val
  %b_val = load i32, ptr %b, align 4

  ; Perform integer addition: %sum = %a_val + %b_val
  %sum = add i32 %a_val, %b_val

  ; Call printf to output the result
  ; Pass format string and the computed sum
  %printf_call = call i32 (ptr, ...) @printf(ptr @.output_fmt, i32 %sum)

  ; Return 0 to indicate successful program execution
  ret i32 0
}
```

## Building it for our TA running WSL on a Windows VM on a Mac {.scrollable}

(we were worried about them not having the right dynamic libraries)

Using nix!

## The nix code

```{.nix .smallcode}
{
  lib,
  rustPlatform,
  libxml2,
  libffi,
  zlib,
  llvm,
  llvmPackages,
  stdenv,
  musl,
  pkg-config,
  writeShellScriptBin,
  static ? false,
  ...
}:
let
  static_libxml2 = (
    libxml2.overrideAttrs (old: {
      configureFlags = (old.configureFlags or [ ]) ++ [
        "--enable-static"
        "--with-pic"
        "--without-lzma"
      ];
    })
  );
  static_libffi = (
    libffi.overrideAttrs (old: {
      configureFlags = (old.configureFlags or [ ]) ++ [
        "--enable-static"
        "--disable-shared"
        "--with-pic"
      ];
    })
  );
  llvmWrapped = writeShellScriptBin "llvm-config" ''
    exec ${llvm.dev}/bin/llvm-config "$@" | sed 's/-lrt//g; s/-ldl//g; s/-lm//g'
  '';
in
rustPlatform.buildRustPackage {
  pname = "compiler";
  version = "0.0.1";
  src = ../.;

  cargoLock = {
    lockFile = ../Cargo.lock;
  };

  nativeBuildInputs = [
    pkg-config
  ];

  buildInputs = [
    llvm
    stdenv.cc.cc.lib
  ]
  ++ (
    if static then
      [
        musl
        musl.dev
      ]
    else
      [
        libxml2.dev
        zlib
      ]
  );

  preBuild = ''
    ${
      if static then
        ''
          export LLVM_SYS_150_PREFIX="${llvmWrapped}"
          export NIX_LDFLAGS="-L${static_libffi.out}/lib -lffi"
          export PKG_CONFIG_ALL_STATIC=1
          export PKG_CONFIG_PATH="$PKG_CONFIG_PATH:${static_libxml2.dev}/lib/pkgconfig"

          export RUSTFLAGS="-C target-feature=+crt-static -C relocation-model=static -L ${llvmPackages.libcxx.out}/lib -L ${stdenv.cc.cc.lib}/lib -L ${zlib.static}/lib $(pkg-config --libs-only-L libxml-2.0)"
        ''
      else
        ''
          export LLVM_SYS_150_PREFIX="${llvm.dev}"
          export NIX_LDFLAGS="-L${libffi.out}/lib -lffi"
        ''
    }
  '';

  cargoBuildFlags = lib.optional static "--target=x86_64-unknown-linux-musl";

  meta.mainProgram = "compiler";
}
```

## Build it!

```bash
nix run github:404wolf/typescripten

# or if you want to wait 8 hours to compile:

nix run github:404wolf/typescripten#build.static
```

## You should come to linux club!

Join Case's Linux Club for more of this!

::: {.r-stack}

![](./images/join.png)

:::
